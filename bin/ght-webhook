#!/usr/bin/env ruby

# (c) 2016 - onwards Georgios Gousios <gousiosg@gmail.com>
#
# MIT licensed, see LICENSE in top level dir
#
# Minimal GitHub webhook for use with GHTorrent.

require 'sinatra'
require 'bunny'
require 'mongo'
require 'yaml'
require 'json'
require 'openssl'
require 'json'
require 'thread'
require_relative '../lib/ghtorrent/api_client.rb'
# require 'ghtorrent/settings'
require 'ghtorrent/logging'

# include GHTorrentWebhook
# include GHTorrent::Persister
# include GHTorrent::Settings
include GHTorrent::Logging
include GHTorrent::APIClient
include GHTorrent::Logging

@@semaphore = Mutex.new
def configuration
  configuration = if ENV['CONFIG'].nil?
             if ARGV[0].nil?
               'config.yaml'
             else
               ARGV[0]
             end
           else
             ENV['CONFIG']
           end

  @settings ||= YAML::load_file configuration
  @settings
end

configure do
  if configuration['mongo']['username'].nil?
    db = Mongo::Client.new(["#{configuration['mongo']['host']}:#{configuration['mongo']['port']}"],
                           :database => configuration['mongo']['db'],
                           :ssl => true)
  else
    db = Mongo::Client.new(["#{configuration['mongo']['host']}:#{configuration['mongo']['port']}"],
                           :database => configuration['mongo']['db'],
                           :user => configuration['mongo']['username'],
                           :password => configuration['mongo']['password'],
                           :ssl => true)
  end

  # Stash away the @settings value and define a [] method to access it.  The "settings"
  # var her is actually the Sinatra application. The GHT config() method will try to run
  # (literally) settings[x] at a time when the "settings" field is the Sinatra app.  By adding
  # [] to Sinatra, we can trick GHT and get the config values accessible.
  # TODO figure out Ruby closures to eliminate the global
  $nested_settings = @settings
  def settings.[](x)
    $nested_settings[x]
  end

  db.database.collection_names
  STDERR.puts "Connection to MongoDB: #{configuration['mongo']['host']} succeeded"

  set :mongo, db
  begin
    conn = Bunny.new(:host => configuration['amqp']['host'],
                     :port => configuration['amqp']['port'],
                     :username => configuration['amqp']['username'],
                     :password => configuration['amqp']['password'],
                     :network_recovery_interval => 7)
    conn.start
  rescue Exception => e
    sleep 2
    retry
  end

  ch = conn.create_channel
  STDERR.puts "Connection to RabbitMQ: #{configuration['amqp']['host']} succeded"

  @exchange = ch.topic(configuration['amqp']['exchange'], :durable => true,
                         :auto_delete => false)

  set :rabbit, @exchange
end

get '/' do
  "ght-web-hook: use POST instead\n"
end

post '/' do
  #Verify the signature
  request.body.rewind
  payload_body = request.body.read
  if verify_signature(payload_body)
    puts "verified\r\n"

    # Read and parse event
    begin
      event = JSON.parse(payload_body)
    rescue StandardError => e
      puts e
      halt 400, "Error parsing object #{request.body.read}"
    end

    pull_events(event)
  else
    print "Could not verify\r\n"
    halt 500
  end
end

def pull_events(event)
  begin
    puts "Received event for repo: #{event['repository']['full_name']}\r\n"

    page = 1
    until page > configuration['mirror']['history_pages_back']
      url = "#{configuration['mirror']['urlbase']}repos/#{event['repository']['full_name']}/events?page=#{page}&per_page=100"
      puts "URL is: #{url}"

      begin
        r = paged_api_request(url, 1)
      rescue Exception => e
        puts "#{configuration['mirror']['urlbase']}: Retrieved all pages. exiting"
        puts e
        return
      end

      if r == nil
        return
      end

      # TODO: Replace this semaphore with:
      #   1. Do HTTP request (above)
      #   2. Call a new synchronized function whose logic is: if the largest
      #      Event ID in HTTP response is > than the largest event ID stored
      #      in a dictionary that maps repositories to their most recently added
      #      event ID, then update the dictionary's value and return the previously
      #      stored event ID
      #   3. If the synchronized function's response indicates that values need to be
      #      stored, begin storing values from the current highest event ID returned
      #      by the HTTP request and stop before adding the event ID that was returned
      #      by the synchronized function.
      #
      @@semaphore.synchronize do
        r.each do |e|
          # Save to MongoDB, if it is not there yet
          if settings.mongo['events'].find('id' => e["id"]).count == 0
            settings.mongo['events'].insert_one(e)

            # Publish to RabbitMQ
            key = "evt.#{e['type']}"
            settings.rabbit.publish e["id"], :persistent => true, :routing_key => key
            settings.rabbit.publish e["id"], :persistent => true, :routing_key => "bot.#{key}"
            settings.rabbit.publish "#{key} #{e["id"]}", :persistent => true, :routing_key => "log"
            settings.rabbit.publish e["id"], :persistent => true, :routing_key => "evt.Flow"
            puts "#{event['repository']['full_name']}: Adding event to mongo with id: #{e["id"]}\r\n"
          else
            puts "#{event['repository']['full_name']}: Finished grabbing all new events"
            return
          end
        end
      end

      page += 1
    end
    rescue Exception => e
      print e
  end
end

def verify_signature(payload_body)
  if configuration['debug'] and not configuration['debug']['validate_hooks']
    return true
  end

  signature = 'sha1=' + OpenSSL::HMAC.hexdigest(OpenSSL::Digest.new('sha1'), ENV['SECRET_KEY'], payload_body)

  if Rack::Utils.secure_compare(signature, request.env['HTTP_X_HUB_SIGNATURE'])
    return true
  else
    return false
  end
end

